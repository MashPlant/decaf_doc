# 数据流分析及优化概述

原理课上讲解了两种数据流分析的方法：向前流的到达-定值分析和向后流的活跃变量分析，公式分别如下：

到达-定值分析：

$$
Out(bb) = Gen(bb) \cup (In(bb) - Kill(bb))\\
In(bb) = \cup_{bb' \text{ is predecessor of } bb} Out(bb')\\
$$

活跃变量分析：

$$
LiveIn(bb) = LiveUse(bb) \cup (LiveOut(bb) - Def(bb))\\
LiveOut(bb) = \cup_{bb' \text{ is successor of } bb} LiveIn(bb')\\
$$

大家也许注意到了，如果进行如下的替换：$$Out \leftrightarrow LiveIn$$，$$Gen \leftrightarrow LiveUse$$，$$In \leftrightarrow LiveOut$$，$$Kill \leftrightarrow Def$$，这两个公式就完全一样了。正因如此，框架中的`flow.rs`只提供了向前流的数据流分析，但是它也可以用于活跃变量分析。

数据流分析并不只有到达-定值分析和活跃变量分析这两种，我们进行的四种分析/优化中，公共表达式提取，复写传播和常量传播都对应于自己的数据流分析方法，而死代码消除是基于活跃变量分析的。前面三个属于向前的数据流分析，后面一个属于向后流的数据流分析。

数据流分析有自己的一套通用的框架：

$$(D, V, \land, F)$$

其中$$D$$表示数据流分析的方向，分为前向和后向两种；$$V$$表示数据流分析的值集，也就是流动的东西，比如对于到达-定值分析是定值语句，对于活跃变量分析是变量；$$F$$表示传递函数，也就是信息流过基本块后会发生什么变化，对应于上面给出的两个方程组中的第一行。

而$$\land$$表示交半格上的交汇运算符，对应于上面给出的两个方程组中的第二行，它刻画的是多个基本块的信息流入一个基本块时的交汇方式。到达-定值分析和活跃变量分析中，交汇方式都是对集合取并集，但也还有其它的交汇方式，比如对于公共表达式提取，复写传播和常量传播这三者用到的数据流分析方法，采用的交汇方式都是集合取交集。

关于半格的更深入的知识可以参考[wiki](https://en.wikipedia.org/wiki/Semilattice)，关于传递函数自身的性质对于数据流分析的结果的影响可以参考龙书的对应章节，这些东西不是一定要精确的理解，有个大概的印象即可。

在实验框架中，`flow.rs`中提供了struct `Flow`，它负责用bitset的形式存储各个集合和迭代计算，这主要是为了效率起见，虽然实现的代码变得更加复杂了，但是对外部暴露的接口还是相对易用的。在填写了$$Gen$$，$$Kill$$(或者是$$LiveUse$$，$$Def$$)后，调用`solve(graph)`函数即可迭代解出数据流方程，其中`graph`是用来描述基本块间连接关系的迭代器。这个策略对于公共表达式提取，复写传播和死代码消除都适用，但是对于常量传播并不适用，它需要自己的求解方法，不过大致的思想是类似的。

`flow.rs`中提供了一个trait `Meet`，它表示交汇运算符，提供了`Or`和`And`两个实现，分别对应于集合(bitset)的并和交。