# 死代码消除

死代码消除即无用代码消除，和不可达代码消除是两个概念。前者指的是消除执行之后没有任何作用的代码，后者指的是消除永远无法被执行到的代码。

死代码消除基于活跃变量分析，本来这一节应该是这几种优化中最简单的一个的(从代码行数可以直接看出)，不过因为这是大家的实验任务，所以这里还是讲解的详细一些：

对于基本块或单条语句，定义以下四个集合

1. $$Def$$：在引用**前**被定值的变量
2. $$LiveUse$$：在定值**前**被引用的变量
3. $$LiveIn$$：在进入基本块/语句前活跃的变量
4. $$LiveOut$$：在离开基本块/语句后活跃的变量

算法的大致流程是首先计算基本块级别的$$Def$$和$$LiveUse$$，然后以此解出基本块级别的$$LiveIn$$和$$LiveOut$$，然后利用基本块级别的$$LiveOut$$来计算语句级别的$$LiveOut$$，最后执行死代码消除。

1. 对于基本块级别的$$Def$$和$$LiveUse$$的计算，集合定义中的"引用**前**"和"定值**前**"很重要，也就是说如果基本块中有一条语句先对某变量定值，后面的一条语句引用它，那么这个变量是不可能属于$$LiveUse$$的。此外对于`x = x + y`这种corner case，不难想象应该是先引用了`x`，然后才给`x`定值
2. 对于方程的求解，`Flow`已经提供了求解的工具，但是它是基于向前数据流的。根据之前的讲解大家应该知道怎么利用这个向前数据流的求解器来求解向后数据流
3. 对于语句级别的$$LiveOut$$的计算，采用的方法是在每个基本块上反向遍历tac，之所以是反向遍历也是因为这是向后数据流。在反向遍历的过程中不断修改当前的$$LiveOut$$让它变成当前tac的$$LiveOut$$，具体方法请自己思考
4. 最后的死代码删除非常直白：如果在一条tac语句处它的赋值目标(如果有的话)不活跃，那么可以删除这条语句。为了删除语句大家可能要阅读一下tac链表及迭代器的相关代码和文档。

还有一个小问题需要注意：有些tac语句是有副作用的，例如函数调用，所以对于一条`a = call b`，即使`a`不再活跃，也只能把它转化为`call b`而不能整个消除。

还有一些语句的"副作用"不是很明确，比如load指令`a = *(b + imm)`和一部分计算指令，如除0，有符号整数溢出等(依平台而定)，可能会导致程序崩溃，但是优化的时候可以不把这当成是副作用：按照c/c++常用的说法这叫未定义行为，这可以减轻编译器作者的负担，他可以假定程序永远没有未定义行为，并以此为依据来优化。

目前decaf并没有这方面的严格的语言标准，为了让大家的实现尽量简单，我们姑且认为不合法的访存和运算都是未定义行为，所以这样的指令是可以优化掉的。