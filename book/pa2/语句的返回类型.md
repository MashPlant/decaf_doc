# 语句的返回类型

语句的返回类型的检查在类型检查中完成，不过因为它的规则比较复杂，这里单独列出来讲一下。

每个语句(`Stmt`)都有自己的返回类型，规则列举如下：
- `Assign`：返回类型为空(`Ty::void()`，下同)
- `LocalVarDef`：返回类型为空
- `ExprEval`：返回类型为空
- `Skip`：返回类型为空
- `If`：定义`on_false`分支的返回类型为：如果`on_false`分支存在，则就是它的返回类型，否则为空；`If`的返回类型为两个分支的返回类型的最小上界
- `While`：返回类型为空
- `For`：返回类型为空
- `Return`：若`Return`语句无返回值则返回类型为空，否则返回类型为返回值值的类型
- `Print`：返回类型为空
- `Break`：返回类型为空
- `Block`：顺序遍历`Block`中的每条语句，遇到第一条返回类型不为空的语句或者`Break`语句时停下
  - 如果是返回类型不为空的语句，则`Block`的返回类型为这个类型
  - 如果是`Break`语句，则`Block`的返回类型为空
  - 如果没有找到这样的语句，则`Block`的返回类型为空
  - 额外地，如果在遇到第一条返回类型不为空的语句或者`Break`语句后，后序还有任何语句，则汇报一个不可达语句的**错误**(许多语言中不可达语句都是警告，不过在java中这被认为是一个错误，参考[section 14.21 of the JLS](https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.21))

上面提到了两个类型的最小上界，对此定义如下：
- 若其中任何一个为空，则最小上界为空
- 否则，若其中任何一个为错误(`Ty::error()`，下同)，则最小上界为错误
- 否则，若二者是相同类型的非空基本类型(`int`，`bool`，`string`，`null`)T，则最小上界为T
- 否则，若二者一个是`null`类型，一个是对象类型T，则最小上界为T
- 否则，若二者分别为对象类型T1，T2，则在继承树上寻找二者的最近公共祖先(lca，Least Common Ancestor)，若lca存在则最小上界为lca，否则为错误
- 否则，若二者都是函数类型，若二者的参数列表完全相同，且返回类型的lca存在，则最小上界为参数列表为二者任一的参数列表，返回类型为lca的函数类型，否则为错误
- 否则，若二者是维度都等于D的数组类型，则先求其元素类型的最小上界T，若E为错误则最小上界为错误，否则最小上界为维度等于D，元素类型为T的数组类型
- 否则，最小上界为错误

如果一个函数的返回类型不为空，然而它的`body`语句块的返回类型为空，需要汇报一个对应的错误。

大家可能会发现，对于`while`和`for`循环的检测粒度似乎太粗了一点：如果是`while (true)`或者`for (...; true; ...)`的情况，这个循环本身并不会结束。事实上，除非循环被`break`跳出，这样的循环如果想要结束，只能通过其中的`return`语句，所以它们的返回类型也就不一定为空了。

例如java中就特别处理了这种情况，javac会汇报返回类型不为空的函数可能不返回值这个错误，但如果`while`的条件是常量表达式且结果为`true`，并且其中没有作用于它的`break`语句，则认为它一定有返回值，不会造成这个错误。

但是也有像rust这样的例子，rustc也强制要求保证返回类型不为空的函数一定返回值，但是它不会特殊处理`while (true)`，而是额外引入了`loop`，效果等价于`while (true)`，但在其中没有作用于它的`break`语句时认为它一定有返回值。

目前我们为了简单起见，这两种比较合理的方案都没有采用(第一种方案需要精确定义常量表达式，并且需要在类型检查阶段做常量表达式求值；第二种方案需要增加新的关键字)，而是直接粗暴地认为循环语句的返回值为空。