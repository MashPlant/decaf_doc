## lexer

`#[lex(TomlOfLexer)]`的toml中应该包含`priority`和`lexical`两个字段，前者用于指定终结符的优先级和结合性，**排在后面的优先级高**；后者用于指定终结符的正则表达式，当一个字符串片段可以被解释成两种终结符时(例如`int`可以被解释成`Int`或者`Identifier`)，选择的原则是尽量选长的匹配，如果两个匹配一样长，**排在前面的优先级高**。

一个比较简单的`#[lex(TomlOfLexer)]`的例子如下：

```rust
#[lex(r##"
priority = [
  { assoc = 'left', terms = ['Add', 'Sub'] },
  { assoc = 'left', terms = ['Mul', 'Div', 'Mod'] },
]

[lexical]
'void' = 'Void'
'int' = 'Int'
...
'\+' = 'Add'
'-' = 'Sub'
'\*' = 'Mul'
'/' = 'Div'
'%' = 'Mod'
'//[^\n]*' = '_Eps'
'\s+' = '_Eps'
'\d+|(0x[0-9a-fA-F]+)' = 'IntConst'
'[A-Za-z][_0-9A-Za-z]*' = 'Identifier'
'.' = '_Err'
"##)]
```

这其中`Add`，`Sub`这些就是终结符的名字，在后面描述产生式的时候会用到，产生式中不支持直接用终结符的字符串形式来表示终结符，例如yacc/bison中可以写`Expr: Expr '+' Expr`，lalr1中是不行的，只能写成`Add`。`_Eps`是一个内建的终结符，表示解析出这个结果时，lexer不应该告诉parser找到了一个终结符，而是忽略它继续解析下去，它在这里表示空字符或者注释。`_Err`也是一个内建的终结符，表示无法识别的结果，这里在识别到任意字符，且不能解读为之前的任何一个模式的时候返回它。

re2dfa支持一个正则表达式的子集，这里列举几个比较常见但不支持的用法

1. "{n}"，"{m,n}"，'^'，'$'，'?'，但是'{'，'}'，'^'，'$'，'?'仍然需要用'\'来转义，直接用会报错
2. "()"没有分组作用(当然，因为这里根本没有分组这个概念)
3. 只支持贪婪匹配
4. "\w"，而且遇到"\w"会报错

其余功能的支持也不一定完整，如果遇到了什么不符合直觉的结果可以把lexer单独拿出来调试一下，如果的确是re2dfa没有支持的话，就暂且换一个更简单的方法来实现吧，毕竟理论上正则只需要拼接，'|'和'*'就可以实现所有功能了。